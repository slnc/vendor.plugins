require 'iconv'
require 'base64'

module RubyMixings
  module FloatMixing
    def to_02f
    '%.2f' % self
    end
  end
  
  module StringMixing
    def tob64u
      Base64.encode64(self).strip.gsub('+', '-').gsub('/', '_').gsub('=', '~')
    end
    
    def fromb64u
      Base64.decode64(self.strip.gsub('-', '+').gsub('_', '/').gsub('~', '='))
    end
    
    def normalize
      newstr = self.to_s.clone
      newstr.gsub!('á', 'a')
      newstr.gsub!('é', 'e')
      newstr.gsub!('í', 'i')
      newstr.gsub!('ó', 'o')
      newstr.gsub!('ú', 'u')
      newstr.gsub!('Á', 'A')
      newstr.gsub!('É', 'E')
      newstr.gsub!('Í', 'I')
      newstr.gsub!('Ó', 'O')
      newstr.gsub!('Ú', 'U')
      newstr.gsub!('ñ', 'n')
      newstr.gsub!('Ñ', 'n')
      newstr.gsub!(' ', '-')
      
      newstr.gsub!(' ', '-')
      begin
        Iconv.iconv('ascii//translit', 'utf-8', newstr)[0]
      rescue
        newstr
      end
    end
    
    def bare
      self.to_s.normalize.gsub(/[^a-zA-Z0-9_.-]/, '_').downcase.gsub('[', '').gsub(']', '')
    end
  end
  
  module HashMixing
    # author: http://blog.caboo.se/
    # lets through the keys in the argument
    # >> {:one => 1, :two => 2, :three => 3}.pass(:one)
    # => {:one=>1}
    # Siempre compara símbolos
    def pass_sym(*keys)
      tmp = self.clone
      tmp.delete_if {|k,v| ! keys.include?(k.to_sym) }
      tmp
    end
    
    # blocks the keys in the arguments
    # >> {:one => 1, :two => 2, :three => 3}.block(:one)
    # => {:two=>2, :three=>3}
    def block_sym(*keys)
      tmp = self.clone
      tmp.delete_if {|k,v| keys.include?(k.to_sym) }
      tmp
    end
  end
  
  module MathMixing
    def variance(population)
      n = 0
      mean = 0.0
      s = 0.0
      population.each { |x|
        n = n + 1
        delta = x - mean
        mean = mean + (delta / n)
        s = s + delta * (x - mean)
      }
      # if you want to calculate std deviation
      # of a sample change this to "s / (n-1)"
      return s / n
    end
    
    def mean(population)
      return population.sum / population.size.to_f
    end
    
    # calculate the standard deviation of a population
    # accepts: an array, the population
    # returns: the standard deviation
    def standard_deviation(population)
      Math.sqrt(variance(population))
    end 
  end
  
 # module DateTime
 #   def to_time
 #     d = new_offset(0)
 #     d.instance_eval do
 #       Time.utc(year, mon, mday, hour, min, sec,
 #        (sec_fraction * 86400000000).to_i)
 #     end
 #     getlocal
 #   end
 # end
  
  module ObjectMixing
    # private
    def this_method
      caller[0] =~ /`([^']*)'/ and $1
    end
  end
end

class Time
  class << self
    # Used for getting multifield attributes like those generated by a
    # select_datetime into a new Time object. For example if you have
    # following <tt>params={:meetup=>{:"time(1i)=>..."}}</tt> just do
    # following:
    #
    # <tt>Time.parse_from_attributes(params[:meetup],:time)</tt>
    def parse_from_attributes(attrs,field, method=:local)
      Time.send(method.to_s,*attrs.keys.sort.grep(/^#{field.to_s}\(.+\)$/).map{|k| attrs[k]})
    end
  end
end

class Array
  def random
    self[Kernel.rand(self.length)]
  end
  
  #def sum
  #  return 0
  #end
  
  def sum2
    begin
      inject(0) { |sum, x| sum + x }
    rescue
      p self
      raise "fuck"
    end
    # return 0
  end
  
  def mean
   (size > 0) ? sum2.to_f / size : 0
  end
  
  def percentile(percent)
    # n: values
    # percent: 0.0 to 1.0
    n = self.sort
    return 0.0 if n.size == 0
    
    k = (n.size - 1) * percent
    f = k.floor
    c = k.ceil
    return n[k.to_i] if f == c
    
    d0 = n[f.to_i] * (c-k)
    d1 = n[c.to_i] * (k-f)
    
    return d0+d1
    
    # el_id = (n.size * percentile)
    
    
  end
  
  def chunk(number_of_chunks)
    chunks = Array.new
    chunk_size = self.size / number_of_chunks
    remainder = self.size % number_of_chunks
    number_of_chunks.times do |c|
      if c < remainder
        chunks << self[((c*chunk_size)+c),(chunk_size+1)]
      else
        chunks << self[((c*chunk_size)+remainder),chunk_size]
      end
    end
    chunks
  end
  # alias / chunk
end






class MarkovChainer
  attr_reader :order
  def initialize(order)
    @order = order
    @beginnings = []
    @freq = {}
  end
  
  def add_text(text)
    # make sure each paragraph ends with some sentence terminator
    text.gsub!(/\n\s*\n/m, ".")
    text << "."
    seps = /([.!?])/
    sentence = ""
    text.split(seps).each { |p|
      if seps =~ p
        add_sentence(sentence, p)
        sentence = ""
      else
        sentence = p
      end
    }
  end
  
  # ...
  
  private
  
  def add_sentence(str, terminator)
    words = str.scan(/[\w']+/)
    return unless words.size > order # ignore short sentences
    words << terminator
    buf = []
    words.each { |w|
      buf << w
      if buf.size == order + 1
       (@freq[buf[0..-2]] ||= []) << buf[-1]
        buf.shift
      end
    }
    @beginnings << words[0, order]
  end
  
  # ...
  def generate_sentence
    res = @beginnings[rand(@beginnings.size)]
    loop {
      unless nw = next_word_for(res[-order, order])
        return res[0..-2].join(" ") + res.last
      end
      res << nw
    }
  end
  
  private
  
  # ...
  
  def next_word_for(words)
    arr = @freq[words]
    arr && arr[rand(arr.size)]
  end
end