require 'iconv'
require 'base64'
Time

module RubyMixings
  # if nil # ruby 1.8.7
  module DateMixing
    GM_MONTHNAMES = [nil, 'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo',
        'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 
        'Diciembre']
    
    GM_ABBR_MONTHNAMES = [nil, 'Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun',
        'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dec']
    
    GM_DAYNAMES = ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 
        'Viernes', 'Sábado']
    
    GM_ABBR_DAYNAMES = ['D', 'L', 'M', 'X', 'J', 'V', 'S']
    
    def strftime_es(*args)
      to_time.strftime_es(*args)
    end
  end
  
  module FloatMixing
    def to_02f
    '%.2f' % self
    end
  end
  
  module StringMixing
    def hostname_from_url
      begin 
        hostname = URI.parse(self).host.gsub(/www./, '') 
      rescue
        hostname = self
      end
      hostname
    end
    
    def tob64u
      Base64.encode64(self).strip.gsub('+', '-').gsub('/', '_').gsub('=', '~')
    end
    
    def fromb64u
      Base64.decode64(self.strip.gsub('-', '+').gsub('_', '/').gsub('~', '='))
    end
    
    def normalize
      newstr = self.to_s.clone
      newstr.gsub!('á', 'a')
      newstr.gsub!('é', 'e')
      newstr.gsub!('í', 'i')
      newstr.gsub!('ó', 'o')
      newstr.gsub!('ú', 'u')
      newstr.gsub!('Á', 'A')
      newstr.gsub!('É', 'E')
      newstr.gsub!('Í', 'I')
      newstr.gsub!('Ó', 'O')
      newstr.gsub!('Ú', 'U')
      newstr.gsub!('ñ', 'n')
      newstr.gsub!('Ñ', 'n')
      newstr.gsub!(' ', '-')
      
      newstr.gsub!(' ', '-')
      begin
        Iconv.iconv('ascii//translit', 'utf-8', newstr)[0]
      rescue
        newstr
      end
    end
    
    def bare
      self.to_s.normalize.gsub(/[^a-zA-Z0-9_.-]/, '_').downcase.gsub('[', '').gsub(']', '')
    end
  end
  
  module HashMixing
    # author: http://blog.caboo.se/
    # lets through the keys in the argument
    # >> {:one => 1, :two => 2, :three => 3}.pass(:one)
    # => {:one=>1}
    # Siempre compara símbolos
    def pass_sym(*keys)
      tmp = self.clone
      tmp.delete_if {|k,v| ! keys.include?(k.to_sym) }
      tmp
    end
    
    # blocks the keys in the arguments
    # >> {:one => 1, :two => 2, :three => 3}.block(:one)
    # => {:two=>2, :three=>3}
    def block_sym(*keys)
      tmp = self.clone
      tmp.delete_if {|k,v| keys.include?(k.to_sym) }
      tmp
    end
  end
  
  module MathMixing
    def variance(population)
      n = 0
      mean = 0.0
      s = 0.0
      population.each { |x|
        n = n + 1
        delta = x - mean
        mean = mean + (delta / n)
        s = s + delta * (x - mean)
      }
      # if you want to calculate std deviation
      # of a sample change this to "s / (n-1)"
      return s / n
    end
    
    def mean(population)
      return population.sum / population.size.to_f
    end
    
    # calculate the standard deviation of a population
    # accepts: an array, the population
    # returns: the standard deviation
    def standard_deviation(population)
      Math.sqrt(variance(population))
    end 
    
    def pearson(x, y)
      n=x.length 
      
      sumx=x.inject(0) {|r,i| r + i}
      sumy=y.inject(0) {|r,i| r + i}
      
      sumxSq=x.inject(0) {|r,i| r + i**2}
      sumySq=y.inject(0) {|r,i| r + i**2}
      
      prods=[]; x.each_with_index{|this_x,i| prods << this_x*y[i]}
      pSum=prods.inject(0){|r,i| r + i}
      
      # Calculate Pearson score 
      num=pSum-(sumx*sumy/n) 
      den=((sumxSq-(sumx**2)/n)*(sumySq-(sumy**2)/n))**0.5 
      if den==0
        return 0 
      end
      r=num/den 
      return r       
    end
  end
  
  # module DateTime
  #   def to_time
  #     d = new_offset(0)
  #     d.instance_eval do
  #       Time.utc(year, mon, mday, hour, min, sec,
  #        (sec_fraction * 86400000000).to_i)
  #     end
  #     getlocal
  #   end
  # end
  
  module ObjectMixing
    # private
    def this_method
      caller[0] =~ /`([^']*)'/ and $1
    end
  end
end


class Time
  alias :strftime_nolocale :strftime
  
  def strftime_es(format) # PERF: too slow?
    format = format.dup
    format.gsub!(/%a/, Date::GM_ABBR_DAYNAMES[self.wday])
    format.gsub!(/%A/, Date::GM_DAYNAMES[self.wday])
    format.gsub!(/%b/, Date::GM_ABBR_MONTHNAMES[self.mon])
    format.gsub!(/%B/, Date::GM_MONTHNAMES[self.mon])
    self.strftime_nolocale(format)
  end
  
  class << self
    
    # Used for getting multifield attributes like those generated by a
    # select_datetime into a new Time object. For example if you have
    # following <tt>params={:meetup=>{:"time(1i)=>..."}}</tt> just do
    # following:
    #
    # <tt>Time.parse_from_attributes(params[:meetup],:time)</tt>
    def parse_from_attributes(attrs,field, method=:local)
      Time.send(method.to_s,*attrs.keys.sort.grep(/^#{field.to_s}\(.+\)$/).map{|k| attrs[k]})
    end
  end
end

class Array
  def random
    self[Kernel.rand(self.length)]
  end
  
  #def sum
  #  return 0
  #end
  
  def sum2
    begin
      inject(0) { |sum, x| sum + x }
    rescue
      p self
      raise "it didn't work"
    end
    # return 0
  end
  
  def mean
   (size > 0) ? sum2.to_f / size : 0
  end
  
  def percentile(percent)
    # n: values
    # percent: 0.0 to 1.0
    n = self.sort
    return 0.0 if n.size == 0
    
    k = (n.size - 1) * percent
    f = k.floor
    c = k.ceil
    return n[k.to_i] if f == c
    
    d0 = n[f.to_i] * (c-k)
    d1 = n[c.to_i] * (k-f)
    
    return d0+d1
    
    # el_id = (n.size * percentile)
  end
  
  def chunk(number_of_chunks)
    chunks = Array.new
    chunk_size = self.size / number_of_chunks
    remainder = self.size % number_of_chunks
    number_of_chunks.times do |c|
      if c < remainder
        chunks << self[((c*chunk_size)+c),(chunk_size+1)]
      else
        chunks << self[((c*chunk_size)+remainder),chunk_size]
      end
    end
    chunks
  end
  
  
  # when called without a block, returns an array with each combination.
  # when called with a block, yields each combination to the block.
  def each_choose(k, &block)
    raise ArgumentError, "The combination size (#{k}) must be <= the array size (#{size}).", caller if k > size
    raise ArgumentError, "The combination size (#{k}) cannot be negative.", caller if k < 0
    
    if block == nil
      results = []
      size.choose(k).times { |i| results << choose_index(k, i) }
      return results
    end
    
    size.choose(k).times { |i| yield choose_index(k, i) }
  end

  # returns the combination at index i of self.each_choose(k)
  def choose_index(n, i)
    results = []
    size.times do |x|
      break if n == 0
      threshold = (size - x - 1).choose(n - 1)
      if i < threshold
        results << self[x]
        n -= 1
      else
        i = i - threshold
      end
    end
    return results
  end
end

class Integer
  # calculates binomial coefficient of self choose k
  # not recommended for large numbers as binomial coefficients get large quickly... e.g. 100 choose 50 is 100891344545564193334812497256
  def choose(k)
    return 0 if (k > self)
    n = self
    r = 1
    1.upto(k) do |d|
      r *= n
      r /= d
      n -= 1
    end
    return r
  end
end


class MarkovChainer
  attr_reader :order
  def initialize(order)
    @order = order
    @beginnings = []
    @freq = {}
  end
  
  def add_text(text)
    # make sure each paragraph ends with some sentence terminator
    text.gsub!(/\n\s*\n/m, ".")
    text << "."
    seps = /([.!?])/
    sentence = ""
    text.split(seps).each { |p|
      if seps =~ p
        add_sentence(sentence, p)
        sentence = ""
      else
        sentence = p
      end
    }
  end
  
  # ...
  
  private
  
  def add_sentence(str, terminator)
    words = str.scan(/[\w']+/)
    return unless words.size > order # ignore short sentences
    words << terminator
    buf = []
    words.each { |w|
      buf << w
      if buf.size == order + 1
       (@freq[buf[0..-2]] ||= []) << buf[-1]
        buf.shift
      end
    }
    @beginnings << words[0, order]
  end
  
  # ...
  def generate_sentence
    res = @beginnings[rand(@beginnings.size)]
    loop {
      unless nw = next_word_for(res[-order, order])
        return res[0..-2].join(" ") + res.last
      end
      res << nw
    }
  end
  
  private
  
  # ...
  
  def next_word_for(words)
    arr = @freq[words]
    arr && arr[rand(arr.size)]
  end
end
